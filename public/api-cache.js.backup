/**
 * API Caching System
 * Provides intelligent caching for repeated API calls
 */

/* global btoa */

/**
 * Simple browser logger for frontend modules
 */
const APICacheLogger = {
  debug: (message, ...args) => {
    if (
      window.location.hostname === 'localhost' ||
      window.location.hostname === '127.0.0.1'
    ) {
      // eslint-disable-next-line no-console
      console.debug(`[APICache] ${message}`, ...args);
    }
  },
  info: (message, ...args) => {
    // eslint-disable-next-line no-console
    console.info(`[APICache] ${message}`, ...args);
  },
  warn: (message, ...args) => {
    // eslint-disable-next-line no-console
    console.warn(`[APICache] ${message}`, ...args);
  },
  error: (message, ...args) => {
    // eslint-disable-next-line no-console
    console.error(`[APICache] ${message}`, ...args);
  },
};

class APICache {
  constructor(options = {}) {
    this.cache = new Map();
    this.defaultTTL = options.defaultTTL || 5 * 60 * 1000; // 5 minutes
    this.maxSize = options.maxSize || 100;
    this.cleanupInterval = options.cleanupInterval || 60 * 1000; // 1 minute
    this.cleanupTimer = null;

    this.initCleanup();
  }

  /**
   * Generate cache key from URL and options
   * @param {string} url - The URL to cache
   * @param {Object} options - Request options
   * @returns {string} Base64 encoded cache key
   * @throws {Error} When URL is invalid or key generation fails
   */
  generateKey(url, options = {}) {
    try {
      if (!url || typeof url !== 'string') {
        throw new Error('URL must be a non-empty string');
      }

      const keyData = {
        url,
        method: options.method || 'GET',
        body: options.body ? JSON.stringify(options.body) : '',
        headers: options.headers ? JSON.stringify(options.headers) : '',
      };

      // Use safe base64 encoding with fallback
      try {
        return btoa(JSON.stringify(keyData));
      } catch {
        // Fallback to simple hash if btoa fails
        return this.simpleHash(JSON.stringify(keyData));
      }
    } catch (error) {
      APICacheLogger.error('Failed to generate cache key:', error);
      throw new Error(`Cache key generation failed: ${error.message}`);
    }
  }

  /**
   * Simple hash function as fallback for btoa
   * @param {string} str - String to hash
   * @returns {string} Hash string
   */
  simpleHash(str) {
    let hash = 0;
    if (str.length === 0) return hash.toString();
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(36);
  }

  /**
   * Set cache entry
   * @param {string} key - Cache key
   * @param {*} data - Data to cache
   * @param {number} ttl - Time to live in milliseconds
   * @returns {Object} Cache entry
   * @throws {Error} When key is invalid or data cannot be cached
   */
  set(key, data, ttl = this.defaultTTL) {
    try {
      if (!key || typeof key !== 'string') {
        throw new Error('Cache key must be a non-empty string');
      }

      // Remove oldest entries if cache is full
      if (this.cache.size >= this.maxSize) {
        const firstKey = this.cache.keys().next().value;
        if (firstKey) {
          this.cache.delete(firstKey);
        }
      }

      const entry = {
        data,
        timestamp: Date.now(),
        ttl: Math.max(ttl, 1000), // Minimum 1 second TTL
        hits: 0,
      };

      this.cache.set(key, entry);
      return entry;
    } catch (error) {
      APICacheLogger.error('Failed to set cache entry:', error);
      throw new Error(`Cache set failed: ${error.message}`);
    }
  }

  /**
   * Get cache entry
   * @param {string} key - Cache key
   * @returns {*} Cached data or null if not found/expired
   */
  get(key) {
    try {
      if (!key || typeof key !== 'string') {
        return null;
      }

      const entry = this.cache.get(key);

      if (!entry) {
        return null;
      }

      // Check if entry is expired
      if (Date.now() - entry.timestamp > entry.ttl) {
        this.cache.delete(key);
        return null;
      }

      // Update hit count and move to end (LRU)
      entry.hits++;
      const data = entry.data;
      this.cache.delete(key);
      this.cache.set(key, entry);

      return data;
    } catch (error) {
      APICacheLogger.error('Failed to get cache entry:', error);
      return null;
    }
  }

  /**
   * Check if key exists and is valid
   */
  has(key) {
    return this.get(key) !== null;
  }

  /**
   * Delete cache entry
   */
  delete(key) {
    return this.cache.delete(key);
  }

  /**
   * Clear all cache
   */
  clear() {
    this.cache.clear();
  }

  /**
   * Get cache statistics
   */
  getStats() {
    const entries = Array.from(this.cache.values());
    const totalHits = entries.reduce((sum, entry) => sum + entry.hits, 0);
    const avgAge =
      entries.length > 0
        ? entries.reduce((sum, entry) => sum + (Date.now() - entry.timestamp), 0) /
          entries.length
        : 0;

    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      totalHits,
      avgAge: Math.round(avgAge),
      memoryUsage: this.estimateMemoryUsage(),
    };
  }

  /**
   * Estimate memory usage
   */
  estimateMemoryUsage() {
    let totalSize = 0;
    for (const [key, entry] of this.cache) {
      totalSize += key.length * 2; // UTF-16 characters
      totalSize += JSON.stringify(entry.data).length * 2;
      totalSize += 64; // Estimated overhead
    }
    return totalSize;
  }

  /**
   * Initialize cleanup interval
   */
  initCleanup() {
    this.cleanupTimer = setInterval(() => {
      this.cleanup();
    }, this.cleanupInterval);
  }

  /**
   * Destroy cache instance and clear cleanup interval
   */
  destroy() {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = null;
    }
    this.cache.clear();
  }

  /**
   * Remove expired entries
   */
  cleanup() {
    const now = Date.now();
    const keysToDelete = [];

    for (const [key, entry] of this.cache) {
      if (now - entry.timestamp > entry.ttl) {
        keysToDelete.push(key);
      }
    }

    keysToDelete.forEach(key => this.cache.delete(key));

    if (keysToDelete.length > 0) {
      APICacheLogger.info(`Cleaned up ${keysToDelete.length} expired entries`);
    }
  }

  /**
   * Export cache data
   */
  export() {
    const data = {};
    for (const [key, entry] of this.cache) {
      data[key] = entry;
    }
    return data;
  }

  /**
   * Import cache data
   */
  import(data) {
    this.clear();
    for (const [key, entry] of Object.entries(data)) {
      this.cache.set(key, entry);
    }
  }
}

/**
 * Enhanced API Client with Caching
 */

class CachedAPIClient {
  constructor(options = {}) {
    this.cache = new APICache({
      defaultTTL: options.defaultTTL || 5 * 60 * 1000,
      maxSize: options.maxSize || 100,
    });

    this.baseURL = options.baseURL || '';
    this.defaultHeaders = options.defaultHeaders || {};
    this.requestInterceptors = [];
    this.responseInterceptors = [];
  }

  /**
   * Destroy client and cleanup resources
   */
  destroy() {
    if (this.cache && typeof this.cache.destroy === 'function') {
      this.cache.destroy();
    }
    this.requestInterceptors = [];
    this.responseInterceptors = [];
  }

  /**
   * Add request interceptor
   */
  addRequestInterceptor(interceptor) {
    this.requestInterceptors.push(interceptor);
  }

  /**
   * Add response interceptor
   */
  addResponseInterceptor(interceptor) {
    this.responseInterceptors.push(interceptor);
  }

  /**
   * Make HTTP request with caching
   */
  async request(url, options = {}) {
    const fullURL = this.baseURL + url;
    const cacheKey = this.cache.generateKey(fullURL, options);

    // Check cache first (only for GET requests by default)
    const useCache = options.method === 'GET' && options.cache !== false;
    if (useCache) {
      const cached = this.cache.get(cacheKey);
      if (cached) {
        APICacheLogger.debug(`Cache hit for ${url}`);
        return cached;
      }
    }

    // Apply request interceptors
    let requestOptions = {
      method: 'GET',
      headers: { ...this.defaultHeaders, ...options.headers },
      ...options,
    };

    for (const interceptor of this.requestInterceptors) {
      requestOptions = interceptor(requestOptions) || requestOptions;
    }

    try {
      APICacheLogger.debug(`Making request to ${url}`);
      const response = await fetch(fullURL, requestOptions);
      const data = await response.json();

      // Apply response interceptors
      let processedData = data;
      for (const interceptor of this.responseInterceptors) {
        processedData = interceptor(processedData, response) || processedData;
      }

      // Cache successful GET requests
      if (useCache && response.ok) {
        const ttl = options.cacheTTL || this.cache.defaultTTL;
        this.cache.set(cacheKey, processedData, ttl);
      }

      return processedData;
    } catch (error) {
      APICacheLogger.error(`Request failed for ${url}:`, error);
      throw error;
    }
  }

  /**
   * GET request
   */
  get(url, options = {}) {
    return this.request(url, { ...options, method: 'GET' });
  }

  /**
   * POST request
   */
  post(url, data, options = {}) {
    return this.request(url, {
      ...options,
      method: 'POST',
      body: JSON.stringify(data),
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
    });
  }

  /**
   * PUT request
   */
  put(url, data, options = {}) {
    return this.request(url, {
      ...options,
      method: 'PUT',
      body: JSON.stringify(data),
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
    });
  }

  /**
   * DELETE request
   */
  delete(url, options = {}) {
    return this.request(url, { ...options, method: 'DELETE' });
  }

  /**
   * Invalidate cache entries
   */
  invalidate(pattern) {
    const keysToDelete = [];

    for (const key of this.cache.cache.keys()) {
      if (key.includes(pattern)) {
        keysToDelete.push(key);
      }
    }

    keysToDelete.forEach(key => this.cache.delete(key));
    APICacheLogger.info(
      `Invalidated ${keysToDelete.length} cache entries for pattern: ${pattern}`
    );
  }

  /**
   * Preload data
   */
  async preload(requests) {
    const promises = requests.map(async ({ url, options }) => {
      try {
        await this.get(url, options);
      } catch (error) {
        APICacheLogger.warn(`Failed to preload ${url}:`, error);
      }
    });

    await Promise.all(promises);
  }

  /**
   * Get cache statistics
   */
  getCacheStats() {
    return this.cache.getStats();
  }

  /**
   * Clear cache
   */
  clearCache() {
    this.cache.clear();
  }
}

/**
 * Electron API Wrapper with Caching
 */

class CachedElectronAPI {
  constructor() {
    this.cache = new APICache({
      defaultTTL: 10 * 60 * 1000, // 10 minutes for Electron API
      maxSize: 50,
    });
  }

  /**
   * Destroy client and cleanup resources
   */
  destroy() {
    if (this.cache && typeof this.cache.destroy === 'function') {
      this.cache.destroy();
    }
  }

  /**
   * Wrapper for Electron API calls with caching
   */
  async call(methodName, ...args) {
    const cacheKey = this.cache.generateKey(methodName, { args });
    let cached = null;

    try {
      cached = this.cache.get(cacheKey);
      if (cached) {
        APICacheLogger.debug(`ElectronAPI: Cache hit for ${methodName}`);
        return cached;
      }
    } catch (error) {
      APICacheLogger.warn(`Cache retrieval failed for ${methodName}:`, error);
      cached = null;
    }

    // Check if method exists
    if (!window.electronAPI) {
      APICacheLogger.error('window.electronAPI is not available');
      throw new Error('Electron API is not available');
    }

    if (typeof window.electronAPI[methodName] !== 'function') {
      APICacheLogger.error(
        `Electron API method ${methodName} not found or not a function`
      );
      APICacheLogger.debug('Available methods:', Object.keys(window.electronAPI));
      throw new Error(`Electron API method ${methodName} not found`);
    }

    try {
      APICacheLogger.debug(`ElectronAPI: Calling ${methodName} with args:`, args);
      const result = await window.electronAPI[methodName](...args);
      APICacheLogger.debug(`ElectronAPI: ${methodName} result:`, result);

      // Cache successful responses (even if result.success is false, we want to cache the error)
      this.cache.set(cacheKey, result);
      return result;
    } catch (err) {
      APICacheLogger.error(`Error calling ${methodName}:`, err);
      // Don't cache errors that might be transient
      this.cache.delete(cacheKey);
      throw err;
    }
  }

  /**
   * Invalidate cache for specific method
   */
  invalidateMethod(methodName) {
    this.cache.invalidate(methodName);
  }

  /**
   * Clear all cache
   */
  clearCache() {
    this.cache.clear();
  }

  /**
   * Get cache statistics
   */
  getCacheStats() {
    return this.cache.getStats();
  }
}

// Initialize API cache system when DOM is ready and Electron API is available
function initializeAPICache() {
  try {
    // Check if we're in Electron environment
    if (window.electronAPI) {
      window.apiCache = new APICache();
      window.cachedAPI = new CachedAPIClient({
        baseURL: 'http://localhost:3001/api',
      });
      window.cachedElectronAPI = new CachedElectronAPI();
      APICacheLogger.info('API Cache system initialized successfully');
    } else {
      // Web environment - only initialize HTTP client
      window.apiCache = new APICache();
      window.cachedAPI = new CachedAPIClient({
        baseURL: 'http://localhost:3001/api',
      });
      APICacheLogger.info('API Cache system initialized for web environment');
    }
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error('Failed to initialize API Cache system:', error);
    
    // Fallback to direct API calls
    window.cachedElectronAPI = {
      call: async (methodName, ...args) => {
        if (!window.electronAPI || typeof window.electronAPI[methodName] !== 'function') {
          throw new Error(`Electron API method ${methodName} not available`);
        }
        return await window.electronAPI[methodName](...args);
      }
    };
    
    window.cachedAPI = {
      get: async (url) => {
        const response = await fetch(`http://localhost:3001/api${url}`);
        return await response.json();
      }
    };
  }
}

// Initialize API cache system when DOM is ready and Electron API is available
function initializeAPICache() {
  try {
    // Check if we're in Electron environment
    if (window.electronAPI) {
      window.apiCache = new APICache();
      window.cachedAPI = new CachedAPIClient({
        baseURL: 'http://localhost:3001/api',
      });
      window.cachedElectronAPI = new CachedElectronAPI();
      APICacheLogger.info('API Cache system initialized successfully');
    } else {
      // Web environment - only initialize HTTP client
      window.apiCache = new APICache();
      window.cachedAPI = new CachedAPIClient({
        baseURL: 'http://localhost:3001/api',
      });
      APICacheLogger.info('API Cache system initialized for web environment');
    }
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error('Failed to initialize API Cache system:', error);
    
    // Fallback to direct API calls
    window.cachedElectronAPI = {
      call: async (methodName, ...args) => {
        if (!window.electronAPI || typeof window.electronAPI[methodName] !== 'function') {
          throw new Error(`Electron API method ${methodName} not available`);
        }
        return await window.electronAPI[methodName](...args);
      }
    };
    
    window.cachedAPI = {
      get: async (url) => {
        const response = await fetch(`http://localhost:3001/api${url}`);
        return await response.json();
      }
    };
  }
}

// Cleanup function for page unload
function cleanupAPICache() {
  if (window.apiCache && typeof window.apiCache.destroy === 'function') {
    window.apiCache.destroy();
  }
  if (window.cachedAPI && typeof window.cachedAPI.destroy === 'function') {
    window.cachedAPI.destroy();
  }
  if (window.cachedElectronAPI && typeof window.cachedElectronAPI.destroy === 'function') {
    window.cachedElectronAPI.destroy();
  }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeAPICache);
} else {
  // DOM is already ready
  initializeAPICache();
}

// Cleanup on page unload
window.addEventListener('beforeunload', cleanupAPICache);

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { APICache, CachedAPIClient, CachedElectronAPI };
}
  if (window.cachedAPI && typeof window.cachedAPI.destroy === 'function') {
    window.cachedAPI.destroy();
  }
  if (window.cachedElectronAPI && typeof window.cachedElectronAPI.destroy === 'function') {
    window.cachedElectronAPI.destroy();
  }
}

function initializeAPICache() {
  try {
    // eslint-disable-next-line no-console
    console.error('Failed to initialize API Cache system:', error);

    // Fallback to direct API calls
    window.cachedElectronAPI = {
      call: async (methodName, ...args) => {
        if (
          !window.electronAPI ||
          typeof window.electronAPI[methodName] !== 'function'
        ) {
          throw new Error(`Electron API method ${methodName} not available`);
        }
        return await window.electronAPI[methodName](...args);
      },
    };

    window.cachedAPI = {
      get: async url => {
        const response = await fetch(`http://localhost:3001/api${url}`);
        return await response.json();
      },
    };
  }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeAPICache);
} else {
  // DOM is already ready
  initializeAPICache();
}

// Cleanup on page unload
window.addEventListener('beforeunload', cleanupAPICache);

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { APICache, CachedAPIClient, CachedElectronAPI };
}
